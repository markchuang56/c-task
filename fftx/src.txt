ttp://blog.csdn.net/syrchina/article/details/6670517

程式碼在2011年全國電子大賽結束後（2011年9月3日）釋出，多個版本，註釋詳細。

[cpp] view
plaincopy
/******************************************************************************* 
** 程式名稱：快速傅立葉變換(FFT)  
** 程式描述：本程式實現快速傅立葉變換  
** 程式作者：宋元瑞  
** 最後修改：2011年4月5日  
*******************************************************************************/  
#include <stdio.h>  
#include <math.h>  
  
#define PI 3.141592653589   //圓周率，12位小數   
#define N 8                 //傅立葉變換的點數   
#define M 3                 //蝶形運算的級數，N = 2^M   
typedef double ElemType;    //原始資料序列的資料型別,可以在這裡設定  
  
typedef struct              //定義複數結構體   
{  
    ElemType real,imag;  
}complex;  
  
complex data[N];            //定義儲存單元，原始資料與負數結果均使用之   
ElemType result[N];         //儲存FFT後複數結果的模  
  
//變址   
void ChangeSeat(complex *DataInput)  
{  
    int nextValue,nextM,i,k,j=0;  
    complex temp;  
      
    nextValue=N/2;                  //變址運算，即把自然順序變成倒位序，採用雷德演算法  
    nextM=N-1;  
    for (i=0;i<nextM;i++)  
    {  
        if (i<j)                 //如果i<j,即進行變址  
        {  
            temp=DataInput[j];  
            DataInput[j]=DataInput[i];  
            DataInput[i]=temp;  
        }  
        k=nextValue;                //求j的下一個倒位序  
        while (k<=j)             //如果k<=j,表示j的最高位為1  
        {  
            j=j-k;                  //把最高位變成0  
            k=k/2;                  //k/2，比較次高位，依次類推，逐個比較，直到某個位為0  
        }  
        j=j+k;                      //把0改為1  
    }                                         
}  
/* 
//變址  
void ChangeSeat(complex *DataInput) 
{ 
    complex Temp[N]; 
    int i,n,New_seat; 
    for(i=0; i<N; i++) 
    { 
        Temp[i].real = DataInput[i].real; 
        Temp[i].imag = DataInput[i].imag; 
    } 
    for(i=0; i<N; i++) 
    { 
        New_seat = 0; 
        for(n=0;n<M;n++) 
        { 
            New_seat = New_seat | (((i>>n) & 0x01) << (M-n-1)); 
        } 
        DataInput[New_seat].real = Temp[i].real; 
        DataInput[New_seat].imag = Temp[i].imag; 
    } 
} 
*/  
//複數乘法   
complex XX_complex(complex a, complex b)  
{  
    complex temp;  
      
    temp.real = a.real * b.real-a.imag*b.imag;  
    temp.imag = b.imag*a.real + a.imag*b.real;  
      
    return temp;  
}  
  
//FFT  
void FFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0;  
    ElemType P=0,T=0;  
    complex W,Temp_XX;  
    //ElemType TempResult[N];  
      
    ChangeSeat(data);  
    for(L=1; L<=M; L++)  
    {  
        B = 1<<(L-1);//B=2^(L-1)  
        for(J=0; J<=B-1; J++)  
        {  
            P = (1<<(M-L))*J;//P=2^(M-L) *J   
            step = 1<<L;//2^L  
            for(K=J; K<=N-1; K=K+step)  
            {  
                W.real =  cos(2*PI*P/N);  
                W.imag = -sin(2*PI*P/N);  
                  
                Temp_XX = XX_complex(data[K+B],W);  
                data[K+B].real = data[K].real – Temp_XX.real;  
                data[K+B].imag = data[K].imag – Temp_XX.imag;  
                  
                data[K].real = data[K].real + Temp_XX.real;  
                data[K].imag = data[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
void IFFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0;  
    ElemType P=0,T=0;  
    complex W,Temp_XX;  
    //ElemType TempResult[N];  
      
    ChangeSeat(data);  
    for(L=1; L<=M; L++)  
    {  
        B = 1<<(L-1);//B=2^(L-1)  
        for(J=0; J<=B-1; J++)  
        {  
            P = (1<<(M-L))*J;//P=2^(M-L) *J   
            step = 1<<L;//2^L  
            for(K=J; K<=N-1; K=K+step)  
            {  
                W.real =  cos(2*PI*P/N);  
                W.imag =  sin(2*PI*P/N);//逆運算，這裡跟FFT符號相反   
                  
                Temp_XX = XX_complex(data[K+B],W);  
                data[K+B].real = data[K].real – Temp_XX.real;  
                data[K+B].imag = data[K].imag – Temp_XX.imag;  
                  
                data[K].real = data[K].real + Temp_XX.real;  
                data[K].imag = data[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
int main(int argc, char *argv[])  
{  
    int i = 0;  
    for(i=0; i<N; i++)//製造輸入序列   
    {  
        data[i].real = sin(2*PI*i/N);  
        printf("%lf ",data[i]);  
    }  
    printf("\n\n");  
      
      
    FFT();//進行FFT計算   
    printf("\n\n");  
    for(i=0; i<N; i++)  
        {printf("%lf ",sqrt(data[i].real*data[i].real+data[i].imag*data[i].imag));}  
      
    IFFT();//進行FFT計算   
    printf("\n\n");  
    for(i=0; i<N; i++)  
        {printf("%lf ",data[i].real/N);}  
    printf("\n");  
    /*for(i=0; i<N; i++) 
        {printf("%lf ",data[i].imag/N);} 
    printf("\n");*/  
    /*for(i=0; i<N; i++) 
        {printf("%lf ",sqrt(data[i].real*data[i].real+data[i].imag*data[i].imag)/N);}*/  
    return 0;  
}  

 

[cpp] view
plaincopy
/******************************************************************************* 
** 程式名稱：快速傅立葉變換(FFT)  
** 程式描述：本程式實現快速傅立葉變換  
** 效能提升：修正了IFFT的bug,使用巨集定義改變N大小  
** 程式版本：V6.5 
** 程式作者：宋元瑞  
** 最後修改：2011年5月16日  
*******************************************************************************/  
#include <stdio.h>  
#include <math.h>  
  
#define PI  3.14159265358979323846264338327950288419716939937510    //圓周率，50位小數   
#define PI2 6.28318530717958647692528676655900576839433879875021  
#define N 1024              //傅立葉變換的點數   
#define M 10                //蝶形運算的級數，N = 2^M   
#define Npart2 512          //建立正弦函式表時取PI的1/2   
#define Npart4 256          //建立正弦函式表時取PI的1/4   
#define FFT_RESULT(x)   (sqrt(data[x].real*data[x].real+data[x].imag*data[x].imag))  
#define IFFT_RESULT(x)  (data[x].real/N)  
typedef float ElemType;     //原始資料序列的資料型別,可以在這裡設定  
  
typedef struct              //定義複數結構體   
{  
    ElemType real,imag;  
}complex;  
  
complex data[N];            //定義儲存單元，原始資料與負數結果均使用之   
ElemType SIN_TABLE[Npart4+1];  
  
//產生模擬原始資料輸入   
void InputData(void)  
{  
    int i;  
    for(i=0; i<N; i++)//製造輸入序列   
    {  
        data[i].real = sin(2*PI*i/N);   //正弦波   
        data[i].imag = 0;  
    }  
}  
//建立正弦函式表   
void CREATE_SIN_TABLE(void)  
{  
    int i=0;   
    for(i=0; i<=Npart4; i++)  
    {  
        SIN_TABLE[i] = sin(PI*i/Npart2);//SIN_TABLE[i] = sin(PI2*i/N);  
    }  
}  
  
ElemType Sin_find(ElemType x)  
{  
    int i = (int)(N*x);  
    i = i>>1;  
    if(i>Npart4)//注意：i已經轉化為0~N之間的整數了！   
    {//不會超過N/2   
        i = Npart2 – i;//i = i – 2*(i-Npart4);  
    }   
    return SIN_TABLE[i];  
}  
ElemType Cos_find(ElemType x)  
{  
    int i = (int)(N*x);  
    i = i>>1;  
    if(i<Npart4)//注意：i已經轉化為0~N之間的整數了！   
    {//不會超過N/2   
        //i = Npart4 – i;  
        return SIN_TABLE[Npart4 – i];  
    }   
    else//i>Npart4 && i<N/2  
    {  
        //i = i – Npart4;  
        return -SIN_TABLE[i – Npart4];  
    }  
}  
  
//變址   
void ChangeSeat(complex *DataInput)  
{  
    int nextValue,nextM,i,k,j=0;  
    complex temp;  
      
    nextValue=N/2;                  //變址運算，即把自然順序變成倒位序，採用雷德演算法  
    nextM=N-1;  
    for (i=0;i<nextM;i++)  
    {  
        if (i<j)                 //如果i<j,即進行變址  
        {  
            temp=DataInput[j];  
            DataInput[j]=DataInput[i];  
            DataInput[i]=temp;  
        }  
        k=nextValue;                //求j的下一個倒位序  
        while (k<=j)             //如果k<=j,表示j的最高位為1  
        {  
            j=j-k;                  //把最高位變成0  
            k=k/2;                  //k/2，比較次高位，依次類推，逐個比較，直到某個位為0  
        }  
        j=j+k;                      //把0改為1  
    }                                         
}                                             
  
//複數乘法   
/*complex XX_complex(complex a, complex b) 
{ 
    complex temp; 
     
    temp.real = a.real * b.real-a.imag*b.imag; 
    temp.imag = b.imag*a.real + a.imag*b.real; 
     
    return temp; 
}*/  
  
//FFT運算函式   
void FFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex W,Temp_XX;  
      
    ChangeSeat(data);//變址   
    //CREATE_SIN_TABLE();  
    for(L=1; L<=M; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
            W.imag =  -Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data[KB].real * W.real-data[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data[KB].real + data[KB].imag*W.real;  
                  
                data[KB].real = data[K].real – Temp_XX.real;  
                data[KB].imag = data[K].imag – Temp_XX.imag;  
                  
                data[K].real = data[K].real + Temp_XX.real;  
                data[K].imag = data[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
//IFFT運算函式   
void IFFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex W,Temp_XX;  
      
    ChangeSeat(data);//變址   
    //CREATE_SIN_TABLE();  
    for(L=1; L<=M; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
              
            W.imag =   Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data[KB].real * W.real-data[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data[KB].real + data[KB].imag*W.real;  
                  
                data[KB].real = data[K].real – Temp_XX.real;  
                data[KB].imag = data[K].imag – Temp_XX.imag;  
                  
                data[K].real = data[K].real + Temp_XX.real;  
                data[K].imag = data[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
//主函式   
int main(int argc, char *argv[])  
{  
    int i = 0;  
      
    CREATE_SIN_TABLE(); //建立正弦函式表 ,這句只需在程式開始時執行一次   
      
    InputData();        //輸入原始資料 ，此處用公式模擬；實際應用時為AD取樣資料   
    FFT();              //進行 FFT計算   
      
    for(i=0; i<N; i++)  
        {printf("%f ",FFT_RESULT(i));}/**/  
      
    IFFT();//進行 IFFT計算   
    for(i=0; i<N; i++)  
        {printf("%f ",IFFT_RESULT(i));}/**/  
      
    return 0;  
}  

 

[cpp] view
plaincopy
/******************************************************************************* 
** 程式名稱：快速傅立葉變換(FFT) 
** 程式描述：本程式實現快速傅立葉變換及其逆變換 
** 效能提升：修正了FFT的bug,變數重新命名,並將 N_FFT改為動態值 
** 程式版本：V6.6 
** 程式作者：宋元瑞 
** 最後修改：2011年5月16日 
*******************************************************************************/  
#include <stdio.h>  
#include <stdlib.h>  
#include <math.h>  
  
//#define OUTPRINT printf  
//#define DEL /##/  
  
#define RESULT(x) sqrt(data_of_N_FFT[x].real*data_of_N_FFT[x].real+data_of_N_FFT[x].imag*data_of_N_FFT[x].imag)  
#define PI  3.14159265358979323846264338327950288419716939937510    //圓周率，50位小數  
#define PI2 6.28318530717958647692528676655900576839433879875021  
int N_FFT=0;                //傅立葉變換的點數  
int M_of_N_FFT=0;           //蝶形運算的級數，N = 2^M  
int Npart2_of_N_FFT=0;      //建立正弦函式表時取PI的1/2  
int Npart4_of_N_FFT=0;      //建立正弦函式表時取PI的1/4  
  
typedef float ElemType;     //原始資料序列的資料型別,可以在這裡設定  
  
typedef struct              //定義複數結構體  
{  
    ElemType real,imag;  
}complex_of_N_FFT,*ptr_complex_of_N_FFT;  
  
ptr_complex_of_N_FFT data_of_N_FFT=NULL;//開闢儲存單元，原始資料與負數結果均使用之  
ElemType* SIN_TABLE_of_N_FFT=NULL;  
  
//產生模擬原始資料輸入  
void InputData(void)  
{  
    int i;  
    for (i=0; i<N_FFT; i++)//製造輸入序列  
    {  
        data_of_N_FFT[i].real = sin(2*PI*i/N_FFT);  //正弦波  
        data_of_N_FFT[i].imag = 0;  
        printf("%f ",data_of_N_FFT[i].real);  
    }  
}  
  
//建立正弦函式表  
void CREATE_SIN_TABLE(void)  
{  
    int i=0;  
    for (i=0; i<=Npart4_of_N_FFT; i++)  
    {  
        SIN_TABLE_of_N_FFT[i] = sin(PI*i/Npart2_of_N_FFT);//SIN_TABLE[i] = sin(PI2*i/N);  
    }  
}  
  
  
ElemType Sin_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);  
    i = i>>1;  
    if (i>Npart4_of_N_FFT)//注意：i已經轉化為0~N之間的整數了！  
    {  
        //不會超過N/2  
        i = Npart2_of_N_FFT – i;//i = i – 2*(i-Npart4);  
    }  
    return SIN_TABLE_of_N_FFT[i];  
}  
  
ElemType Cos_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);  
    i = i>>1;  
    if (i<Npart4_of_N_FFT)//注意：i已經轉化為0~N之間的整數了！  
    {  
        //不會超過N/2  
        //i = Npart4 – i;  
        return SIN_TABLE_of_N_FFT[Npart4_of_N_FFT – i];  
    }  
    else//i>Npart4 && i<N/2  
    {  
        //i = i – Npart4;  
        return -SIN_TABLE_of_N_FFT[i – Npart4_of_N_FFT];  
    }  
}  
  
//變址  
void ChangeSeat(complex_of_N_FFT *DataInput)  
{  
    int nextValue,nextM,i,k,j=0;  
    complex_of_N_FFT temp;  
  
    nextValue=N_FFT/2;                  //變址運算，即把自然順序變成倒位序，採用雷德演算法  
    nextM=N_FFT-1;  
    for (i=0;i<nextM;i++)  
    {  
        if (i<j)                 //如果i<j,即進行變址  
        {  
            temp=DataInput[j];  
            DataInput[j]=DataInput[i];  
            DataInput[i]=temp;  
        }  
        k=nextValue;                //求j的下一個倒位序  
        while (k<=j)             //如果k<=j,表示j的最高位為1  
        {  
            j=j-k;                  //把最高位變成0  
            k=k/2;                  //k/2，比較次高位，依次類推，逐個比較，直到某個位為0  
        }  
        j=j+k;                      //把0改為1  
    }  
}  
  
//複數乘法  
/*complex XX_complex(complex a, complex b) 
{ 
    complex temp; 
 
    temp.real = a.real * b.real-a.imag*b.imag; 
    temp.imag = b.imag*a.real + a.imag*b.real; 
 
    return temp; 
}*/  
  
//FFT運算函式  
void FFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
  
    ChangeSeat(data_of_N_FFT);//變址  
    //CREATE_SIN_TABLE();  
    for (L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for (J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J  
            angle = (double)J/B;            //這裡還可以優化  
            W.imag =  -Sin_find(angle);     //用C++該函式課宣告為inline  
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline  
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for (K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷  
                Temp_XX.real = data_of_N_FFT[KB].real * W.real-data_of_N_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_of_N_FFT[KB].real + data_of_N_FFT[KB].imag*W.real;  
  
                data_of_N_FFT[KB].real = data_of_N_FFT[K].real – Temp_XX.real;  
                data_of_N_FFT[KB].imag = data_of_N_FFT[K].imag – Temp_XX.imag;  
  
                data_of_N_FFT[K].real = data_of_N_FFT[K].real + Temp_XX.real;  
                data_of_N_FFT[K].imag = data_of_N_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
  
//IFFT運算函式  
void IFFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
  
    ChangeSeat(data_of_N_FFT);//變址  
    //CREATE_SIN_TABLE();  
    for (L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for (J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J  
            angle = (double)J/B;            //這裡還可以優化  
  
            W.imag =   Sin_find(angle);     //用C++該函式課宣告為inline  
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline  
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for (K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷  
                Temp_XX.real = data_of_N_FFT[KB].real * W.real-data_of_N_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_of_N_FFT[KB].real + data_of_N_FFT[KB].imag*W.real;  
  
                data_of_N_FFT[KB].real = data_of_N_FFT[K].real – Temp_XX.real;  
                data_of_N_FFT[KB].imag = data_of_N_FFT[K].imag – Temp_XX.imag;  
  
                data_of_N_FFT[K].real = data_of_N_FFT[K].real + Temp_XX.real;  
                data_of_N_FFT[K].imag = data_of_N_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
  
//初始化FFT程式  
//N_FFT是 FFT的點數，必須是2的次方  
void Init_FFT(int N_of_FFT)  
{  
    int i=0;  
    int temp_N_FFT=1;  
    N_FFT = N_of_FFT;                   //傅立葉變換的點數 ，必須是 2的次方  
    M_of_N_FFT = 0;                 //蝶形運算的級數，N = 2^M  
    for (i=0; temp_N_FFT<N_FFT; i++)  
    {  
        temp_N_FFT = 2*temp_N_FFT;  
        M_of_N_FFT++;  
    }  
    printf("\n%d\n",M_of_N_FFT);  
    Npart2_of_N_FFT = N_FFT/2;      //建立正弦函式表時取PI的1/2  
    Npart4_of_N_FFT = N_FFT/4;      //建立正弦函式表時取PI的1/4  
  
    //ptr_complex_of_N_FFT data_of_N_FFT=NULL;//開闢儲存單元，原始資料與負數結果均使用之  
    data_of_N_FFT = (ptr_complex_of_N_FFT)malloc(N_FFT * sizeof(complex_of_N_FFT));  
    //ptr_complex_of_N_FFT SIN_TABLE_of_N_FFT=NULL;  
    SIN_TABLE_of_N_FFT = (ElemType *)malloc((Npart4_of_N_FFT+1) * sizeof(ElemType));  
  
    CREATE_SIN_TABLE();             //建立正弦函式表  
}  
  
//結束 FFT運算，釋放相關記憶體  
void Close_FFT(void)  
{  
    if (data_of_N_FFT != NULL)  
    {  
        free(data_of_N_FFT);          //釋放記憶體  
        data_of_N_FFT = NULL;  
    }  
    if (SIN_TABLE_of_N_FFT != NULL)  
    {  
        free(SIN_TABLE_of_N_FFT);     //釋放記憶體  
        SIN_TABLE_of_N_FFT = NULL;  
    }  
}  
  
//主函式  
int main(int argc, char *argv[])  
{  
    int i = 0;  
  
    Init_FFT(1024);     //初始化各項引數，此函式只需執行一次  
  
    InputData();        //輸入原始資料  
    FFT();              //進行 FFT計算  
  
    printf("\n\n");  
    for (i=0; i<N_FFT; i++)  
    {  
        printf("%f ",RESULT(i));  
    }  
  
    IFFT();//進行 IFFT計算  
    printf("\n\n");  
    for (i=0; i<N_FFT; i++)  
    {  
        printf("%f ",data_of_N_FFT[i].real/N_FFT);  
    }  
  
    Close_FFT();        //結束 FFT運算，釋放相關記憶體  
  
    return 0;  
}  

 

[cpp] view
plaincopy
/******************************************************************************* 
** 模組名稱：快速傅立葉變換(FFT)  
** 模組描述：本程式實現快速傅立葉變換  
** 效能提升：已達到網上同類程式最高速度  
** 模組版本：V6.0 
** 模組作者：宋元瑞  
** 最後修改：2011年5月6日 
*******************************************************************************/  
/******************************************************************************* 
**  程式說明： 
    FFT運算輸入引數 source_Data(i) 是一個N大小的陣列（注意是小括號） 
    FFT運算輸出結果 result_Data(i) 是一個N大小的陣列（注意是小括號） 
**  呼叫舉例： 
int main(int argc, char *argv[]) 
{ 
    int i = 0; 
    ///以下為FFT運算的呼叫方式  
    FFT_prepare();      //為FFT做好準備，此函式只需程式開始時執行一次即可，切勿寫在迴圈中  
    while(1) 
    { 
        for(i=0;i<N_FFT;i++) //輸入原始資料  
            {source_Data(i) = sin(2*PI*i/N_FFT);}//注意inputData後面是小括號  
        FFT();              //進行FFT計算  
        //輸出結果：XXX =  result_Data(i); 
    } 
    return 0; 
} 
*******************************************************************************/   
#ifndef SYRFFT_H  
//#pragma once  
  
//#include <stdio.h>  
#include <math.h>  
  
#define FFT_prepare() CREATE_SIN_TABLE();   //建立正弦函式表   
#define source_Data(i) data_FFT[i].imag     //接收輸入資料的陣列，大小為N   
#define result_Data(i) sqrt(data_FFT[i].real*data_FFT[i].real+data_FFT[i].imag*data_FFT[i].imag)//FFT結果   
  
#define PI  3.14159265358979323846264338327950288419716939937510    //圓周率，50位小數   
#define PI2 6.28318530717958647692528676655900576839433879875021  
#define N_FFT 1024              //傅立葉變換的點數   
#define M_of_N_FFT 10               //蝶形運算的級數，N = 2^M   
#define Npart2_of_N_FFT 512         //建立正弦函式表時取PI的1/2   
#define Npart4_of_N_FFT 256         //建立正弦函式表時取PI的1/4   
  
typedef float ElemType;     //原始資料序列的資料型別,可以在這裡設定  
  
typedef struct              //定義複數結構體   
{  
    ElemType real,imag;  
}complex_of_N_FFT;  
  
complex_of_N_FFT data_FFT[N_FFT];       //存放要進行FFT運輸的資料，運算結果也存放這裡   
ElemType SIN_TABLE[Npart4_of_N_FFT+1];  
  
//產生模擬原始資料輸入   
/* 
void InputData(void) 
{ 
    int i; 
    for(i=0; i<N_FFT; i++)       //製造輸入序列  
    { 
        source_Data(i) = sin(2*PI*i/N_FFT); //模擬輸入正弦波  
        //data_FFT[i].imag = sin(2*PI*i/N); //正弦波  
        //printf("%f ",data_FFT[i].imag); 
    } 
}*/  
//建立正弦函式表   
void CREATE_SIN_TABLE(void)  
{  
    int i=0;   
    for(i=0; i<=Npart4_of_N_FFT; i++)  
    {  
        SIN_TABLE[i] = sin(PI*i/Npart2_of_N_FFT);//SIN_TABLE[i] = sin(PI2*i/N);  
    }  
}  
  
ElemType Sin_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);  
    i = i>>1;  
    if(i>Npart4_of_N_FFT)//注意：i已經轉化為0~N之間的整數了！   
    {//不會超過N/2   
        i = Npart2_of_N_FFT – i;//i = i – 2*(i-Npart4);  
    }   
    return SIN_TABLE[i];  
}  
ElemType Cos_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);  
    i = i>>1;  
    if(i<Npart4_of_N_FFT)//注意：i已經轉化為0~N之間的整數了！   
    {//不會超過N/2   
        //i = Npart4 – i;  
        return SIN_TABLE[Npart4_of_N_FFT – i];  
    }   
    else//i>Npart4 && i<N/2  
    {  
        //i = i – Npart4;  
        return -SIN_TABLE[i – Npart4_of_N_FFT];  
    }  
}  
  
//變址   
void ChangeSeat(complex_of_N_FFT *DataInput)  
{  
    //變址前data_FFT[i].imag儲存了輸入資料，變址後data_FFT[i].real儲存了輸入資料  
    int i,n,New_seat;  
      
    for(i=0; i<N_FFT; i++)  
    {  
        New_seat = 0;  
        for(n=0;n<M_of_N_FFT;n++)  
        {  
            New_seat = New_seat | (((i>>n) & 0x01) << (M_of_N_FFT-n-1));  
        }  
        DataInput[New_seat].real = DataInput[i].imag;  
    }  
    for(i=0; i<N_FFT; i++)  
    {  
        DataInput[i].imag = 0;  
    }  
}                                                        
  
//複數乘法   
/* 
complex_of_N_FFT XX_complex(complex_of_N_FFT a, complex_of_N_FFT b) 
{ 
    complex_of_N_FFT temp; 
     
    temp.real = a.real * b.real-a.imag*b.imag; 
    temp.imag = b.imag*a.real + a.imag*b.real; 
     
    return temp; 
}*/  
  
//FFT運算函式   
void FFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
      
    ChangeSeat(data_FFT);   //變址   
      
    for(L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
            W.imag =  -Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data_FFT[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data_FFT[KB].real * W.real-data_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_FFT[KB].real + data_FFT[KB].imag*W.real;  
                  
                data_FFT[KB].real = data_FFT[K].real – Temp_XX.real;  
                data_FFT[KB].imag = data_FFT[K].imag – Temp_XX.imag;  
                  
                data_FFT[K].real = data_FFT[K].real + Temp_XX.real;  
                data_FFT[K].imag = data_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
  
#define SYRFFT_H  
#endif  
 

[cpp] view
plaincopy
/******************************************************************************* 
** 程式名稱：快速傅立葉變換(FFT)  
** 程式描述：本程式實現快速傅立葉變換  
** 程式版本：V6.0 
** 程式作者：宋元瑞  
** 最後修改：2011年5月6日 
*******************************************************************************/  
  
#include <stdio.h>  
#include "syrFFT_H.h"   //包含FFT運算標頭檔案   
  
//主函式   
int main(int argc, char *argv[])  
{  
    int i = 0;  
      
    //以下3句為FFT運算的呼叫函式   
    FFT_prepare();      //為FFT做好準備，此函式只需程式開始時執行一次即可，切勿寫在迴圈中   
    //while(1)  
    {  
        for(i=0;i<N_FFT;i++)//模擬輸入   
            {source_Data(i) = sin(2*PI*i/N_FFT);}//注意inputData後面是小括號   
        FFT();  
  
        for(i=0; i<N_FFT; i++)//輸出結果   
            {printf("%lf ",result_Data(i));}  
    }   
      
    return 0;  
}  
 


 

[cpp] view
plaincopy
#ifndef FFT_H  
  
#include <stdlib.h>  
#include <math.h>  
  
#define RESULT(x) sqrt(data_of_N_FFT[x].real*data_of_N_FFT[x].real+data_of_N_FFT[x].imag*data_of_N_FFT[x].imag)  
#define PI  3.14159265358979323846264338327950288419716939937510    //圓周率，50位小數   
#define PI2 6.28318530717958647692528676655900576839433879875021  
int N_FFT=0;                //傅立葉變換的點數   
int M_of_N_FFT=0;           //蝶形運算的級數，N = 2^M   
int Npart2_of_N_FFT=0;      //建立正弦函式表時取PI的1/2   
int Npart4_of_N_FFT=0;      //建立正弦函式表時取PI的1/4   
  
typedef float ElemType;     //原始資料序列的資料型別,可以在這裡設定  
  
typedef struct              //定義複數結構體   
{  
    ElemType real,imag;  
}complex_of_N_FFT,*ptr_complex_of_N_FFT;  
  
ptr_complex_of_N_FFT data_of_N_FFT=NULL;//開闢儲存單元，原始資料與負數結果均使用之   
ElemType* SIN_TABLE_of_N_FFT=NULL;  
  
  
//建立正弦函式表   
void CREATE_SIN_TABLE(void)  
{  
    int i=0;   
    for(i=0; i<=Npart4_of_N_FFT; i++)  
    {  
        SIN_TABLE_of_N_FFT[i] = sin(PI*i/Npart2_of_N_FFT);//SIN_TABLE[i] = sin(PI2*i/N);  
    }  
}  
  
ElemType Sin_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);  
    i = i>>1;  
    if(i>Npart4_of_N_FFT)//注意：i已經轉化為0~N之間的整數了！   
    {//不會超過N/2   
        i = Npart2_of_N_FFT – i;//i = i – 2*(i-Npart4);  
    }   
    return SIN_TABLE_of_N_FFT[i];  
}  
ElemType Cos_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);  
    i = i>>1;  
    if(i<Npart4_of_N_FFT)//注意：i已經轉化為0~N之間的整數了！   
    {//不會超過N/2   
        //i = Npart4 – i;  
        return SIN_TABLE_of_N_FFT[Npart4_of_N_FFT – i];  
    }   
    else//i>Npart4 && i<N/2  
    {  
        //i = i – Npart4;  
        return -SIN_TABLE_of_N_FFT[i – Npart4_of_N_FFT];  
    }  
}  
  
//變址   
void ChangeSeat(complex_of_N_FFT *DataInput)  
{  
    int nextValue,nextM,i,k,j=0;  
    complex_of_N_FFT temp;  
      
    nextValue=N_FFT/2;                  //變址運算，即把自然順序變成倒位序，採用雷德演算法  
    nextM=N_FFT-1;  
    for (i=0;i<nextM;i++)  
    {  
        if (i<j)                 //如果i<j,即進行變址  
        {  
            temp=DataInput[j];  
            DataInput[j]=DataInput[i];  
            DataInput[i]=temp;  
        }  
        k=nextValue;                //求j的下一個倒位序  
        while (k<=j)             //如果k<=j,表示j的最高位為1  
        {  
            j=j-k;                  //把最高位變成0  
            k=k/2;                  //k/2，比較次高位，依次類推，逐個比較，直到某個位為0  
        }  
        j=j+k;                      //把0改為1  
    }                                         
}                                             
  
//複數乘法   
/*complex XX_complex(complex a, complex b) 
{ 
    complex temp; 
     
    temp.real = a.real * b.real-a.imag*b.imag; 
    temp.imag = b.imag*a.real + a.imag*b.real; 
     
    return temp; 
}*/  
  
//FFT運算函式   
void FFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
      
    ChangeSeat(data_of_N_FFT);//變址   
    //CREATE_SIN_TABLE();  
    for(L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
            W.imag =  -Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data_of_N_FFT[KB].real * W.real-data_of_N_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_of_N_FFT[KB].real + data_of_N_FFT[KB].imag*W.real;  
                  
                data_of_N_FFT[KB].real = data_of_N_FFT[K].real – Temp_XX.real;  
                data_of_N_FFT[KB].imag = data_of_N_FFT[K].imag – Temp_XX.imag;  
                  
                data_of_N_FFT[K].real = data_of_N_FFT[K].real + Temp_XX.real;  
                data_of_N_FFT[K].imag = data_of_N_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
//IFFT運算函式   
void IFFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
      
    ChangeSeat(data_of_N_FFT);//變址   
    //CREATE_SIN_TABLE();  
    for(L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
              
            W.imag =   Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data_of_N_FFT[KB].real * W.real-data_of_N_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_of_N_FFT[KB].real + data_of_N_FFT[KB].imag*W.real;  
                  
                data_of_N_FFT[KB].real = data_of_N_FFT[K].real – Temp_XX.real;  
                data_of_N_FFT[KB].imag = data_of_N_FFT[K].imag – Temp_XX.imag;  
                  
                data_of_N_FFT[K].real = data_of_N_FFT[K].real + Temp_XX.real;  
                data_of_N_FFT[K].imag = data_of_N_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
  
//初始化FFT程式   
//N_FFT是 FFT的點數，必須是2的次方   
void Init_FFT(int N_of_FFT)  
{  
    int i=0;  
    int temp_N_FFT=1;  
    N_FFT = N_of_FFT;                   //傅立葉變換的點數 ，必須是 2的次方   
    M_of_N_FFT = 0;                 //蝶形運算的級數，N = 2^M   
    for(i=0; temp_N_FFT<N_FFT; i++)  
    {  
        temp_N_FFT = 2*temp_N_FFT;  
        M_of_N_FFT++;  
    }  
    //printf("\n%d\n",M_of_N_FFT);  
    Npart2_of_N_FFT = N_FFT/2;      //建立正弦函式表時取PI的1/2   
    Npart4_of_N_FFT = N_FFT/4;      //建立正弦函式表時取PI的1/4   
      
    //ptr_complex_of_N_FFT data_of_N_FFT=NULL;//開闢儲存單元，原始資料與負數結果均使用之   
    data_of_N_FFT = (ptr_complex_of_N_FFT)malloc(N_FFT * sizeof(complex_of_N_FFT));  
    //ptr_complex_of_N_FFT SIN_TABLE_of_N_FFT=NULL;  
    SIN_TABLE_of_N_FFT = (ElemType *)malloc((Npart4_of_N_FFT+1) * sizeof(ElemType));  
  
    CREATE_SIN_TABLE();             //建立正弦函式表   
}  
//結束 FFT運算，釋放相關記憶體   
void Close_FFT(void)  
{  
    if(data_of_N_FFT != NULL)  
    {  
        free(data_of_N_FFT);          //釋放記憶體  
        data_of_N_FFT = NULL;  
    }  
    if(SIN_TABLE_of_N_FFT != NULL)  
    {  
        free(SIN_TABLE_of_N_FFT);     //釋放記憶體  
        SIN_TABLE_of_N_FFT = NULL;  
    }  
}  
  
#define FFT_H  
#endif  
[cpp] view
plaincopy
/******************************************************************************* 
** 程式名稱：快速傅立葉變換(FFT)  
** 程式描述：本程式實現快速傅立葉變換及其逆變換  
** 效能提升：修正了FFT的bug  
** 程式版本：V6.6 
** 程式作者：宋元瑞  
** 最後修改：2011年5月16日  
*******************************************************************************/  
  
#include "jxust_fft6_6.h"  
  
//產生模擬原始資料輸入 ,在實際應用時替換為AD取樣資料   
void InputData(void)  
{  
    int i;  
    for(i=0; i<N_FFT; i++)//製造輸入序列   
    {  
        data_of_N_FFT[i].real = sin(2*PI*i/N_FFT);  //輸入取樣資料   
        data_of_N_FFT[i].imag = 0;  
    }  
}  
  
//主函式 ，示例如何呼叫FFT運算   
int main(int argc, char *argv[])  
{  
    int i = 0;  
      
    Init_FFT(1024);     //①初始化各項引數，此函式只需執行一次 ; 引數為FFT的點數，必須為2的次方   
      
    InputData();        //②輸入原始資料 ,此處在實際應用時替換為AD取樣資料   
    FFT();              //③進行 FFT計算   
    //for(i=0; i<N_FFT; i++)//④輸出FFT頻譜結果  sqrt(data_of_N_FFT[i].real*data_of_N_FFT[i].real+data_of_N_FFT[i].imag*data_of_N_FFT[i].imag)  
        //{printf("%f ",RESULT(i));}  
      
    IFFT();//進行 IFFT計算   
    //for(i=0; i<N_FFT; i++)//(可選步驟)⑤輸出 IFFT結果 ，濾波時會用到；暫時不用   
        //{printf("%f ",data_of_N_FFT[i].real/N_FFT);}  
    Close_FFT();    //結束 FFT運算，釋放相關記憶體 ;此函式在徹底結束FFT運算後呼叫，   
      
    return 0;  
}  

 

[cpp] view
plaincopy
#ifndef SYRFFT_6_55_H  
  
#include <math.h>  
  
#define FFT_RESULT(x)   (sqrt(data_of_N_FFT[x].real*data_of_N_FFT[x].real+data_of_N_FFT[x].imag*data_of_N_FFT[x].imag))  
#define IFFT_RESULT(x)  (data_of_N_FFT[x].real/N_FFT)  
  
#define PI  3.14159265358979323846264338327950288419716939937510    //圓周率，50位小數   
#define PI2 6.28318530717958647692528676655900576839433879875021  
#define N_FFT           1024        //傅立葉變換的點數   
#define M_of_N_FFT      10          //蝶形運算的級數，N = 2^M   
#define Npart2_of_N_FFT 512         //建立正弦函式表時取PI的1/2   
#define Npart4_of_N_FFT 256         //建立正弦函式表時取PI的1/4   
  
typedef float ElemType;     //原始資料序列的資料型別,可以在這裡設定  
  
typedef struct              //定義複數結構體   
{  
    ElemType real,imag;  
}complex_of_N_FFT,*ptr_complex_of_N_FFT;  
  
complex_of_N_FFT data_of_N_FFT[N_FFT];          //定義儲存單元，原始資料與負數結果均使用之   
ElemType SIN_TABLE_of_N_FFT[Npart4_of_N_FFT+1];  
  
//建立正弦函式表   
void CREATE_SIN_TABLE(void)  
{  
    int i=0;   
    for(i=0; i<=Npart4_of_N_FFT; i++)  
    {  
        SIN_TABLE_of_N_FFT[i] = sin(PI*i/Npart2_of_N_FFT);//SIN_TABLE[i] = sin(PI2*i/N);  
    }  
}  
  
ElemType Sin_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);//注意：i已經轉化為0~N之間的整數了！   
    i = i>>1;// i = i / 2;  
    if(i>Npart4_of_N_FFT)  
    {//根據FFT相關公式，sin()引數不會超過PI， 即i不會超過N/2   
        i = Npart2_of_N_FFT – i;//i = i – 2*(i-Npart4);  
    }   
    return SIN_TABLE_of_N_FFT[i];  
}  
ElemType Cos_find(ElemType x)  
{  
    int i = (int)(N_FFT*x);//注意：i已經轉化為0~N之間的整數了！   
    i = i>>1;  
    if(i < Npart4_of_N_FFT )   
    { //不會超過N/2   
        //i = Npart4 – i;  
        return SIN_TABLE_of_N_FFT[Npart4_of_N_FFT – i];  
    }   
    else //i > Npart4 && i < N/2   
    {  
        //i = i – Npart4;  
        return -SIN_TABLE_of_N_FFT[i – Npart4_of_N_FFT];  
    }  
}  
  
//變址   
void ChangeSeat(complex_of_N_FFT *DataInput)  
{  
    int nextValue,nextM,i,k,j=0;  
    complex_of_N_FFT temp;  
      
    nextValue=N_FFT/2;                  //變址運算，即把自然順序變成倒位序，採用雷德演算法  
    nextM=N_FFT-1;  
    for (i=0;i<nextM;i++)  
    {  
        if (i<j)                 //如果i<j,即進行變址  
        {  
            temp=DataInput[j];  
            DataInput[j]=DataInput[i];  
            DataInput[i]=temp;  
        }  
        k=nextValue;                //求j的下一個倒位序  
        while (k<=j)             //如果k<=j,表示j的最高位為1  
        {  
            j=j-k;                  //把最高位變成0  
            k=k/2;                  //k/2，比較次高位，依次類推，逐個比較，直到某個位為0  
        }  
        j=j+k;                      //把0改為1  
    }                                         
}                                             
  
//複數乘法   
/*complex XX_complex(complex a, complex b) 
{ 
    complex temp; 
     
    temp.real = a.real * b.real-a.imag*b.imag; 
    temp.imag = b.imag*a.real + a.imag*b.real; 
     
    return temp; 
}*/  
  
//FFT運算函式   
void FFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
      
    ChangeSeat(data_of_N_FFT);//變址   
    //CREATE_SIN_TABLE();  
    for(L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
            W.imag =  -Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data_of_N_FFT[KB].real * W.real-data_of_N_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_of_N_FFT[KB].real + data_of_N_FFT[KB].imag*W.real;  
                  
                data_of_N_FFT[KB].real = data_of_N_FFT[K].real – Temp_XX.real;  
                data_of_N_FFT[KB].imag = data_of_N_FFT[K].imag – Temp_XX.imag;  
                  
                data_of_N_FFT[K].real = data_of_N_FFT[K].real + Temp_XX.real;  
                data_of_N_FFT[K].imag = data_of_N_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
  
//IFFT運算函式   
void IFFT(void)  
{  
    int L=0,B=0,J=0,K=0;  
    int step=0, KB=0;  
    //ElemType P=0;  
    ElemType angle;  
    complex_of_N_FFT W,Temp_XX;  
      
    ChangeSeat(data_of_N_FFT);//變址   
    //CREATE_SIN_TABLE();  
    for(L=1; L<=M_of_N_FFT; L++)  
    {  
        step = 1<<L;//2^L  
        B = step>>1;//B=2^(L-1)  
        for(J=0; J<B; J++)  
        {  
            //P = (1<<(M-L))*J;//P=2^(M-L) *J   
            angle = (double)J/B;            //這裡還可以優化   
              
            W.imag =   Sin_find(angle);     //用C++該函式課宣告為inline   
            W.real =   Cos_find(angle);     //用C++該函式課宣告為inline   
            //W.real =  cos(angle*PI);  
            //W.imag = -sin(angle*PI);  
            for(K=J; K<N_FFT; K=K+step)  
            {  
                KB = K + B;  
                //Temp_XX = XX_complex(data[KB],W);  
                //用下面兩行直接計算複數乘法，省去函式呼叫開銷   
                Temp_XX.real = data_of_N_FFT[KB].real * W.real-data_of_N_FFT[KB].imag*W.imag;  
                Temp_XX.imag = W.imag*data_of_N_FFT[KB].real + data_of_N_FFT[KB].imag*W.real;  
                  
                data_of_N_FFT[KB].real = data_of_N_FFT[K].real – Temp_XX.real;  
                data_of_N_FFT[KB].imag = data_of_N_FFT[K].imag – Temp_XX.imag;  
                  
                data_of_N_FFT[K].real = data_of_N_FFT[K].real + Temp_XX.real;  
                data_of_N_FFT[K].imag = data_of_N_FFT[K].imag + Temp_XX.imag;  
            }  
        }  
    }  
}  
  
//初始化FFT程式   
void Init_FFT()  
{  
    CREATE_SIN_TABLE();             //建立正弦函式表   
}  
  
//結束 FFT運算，釋放相關記憶體   
void Close_FFT(void)  
{  
      
}  
  
#define SYRFFT_6_55_H  
#endif  

/******************************************************************************* 
** 程式名稱：快速傅立葉變換(FFT)  
** 程式描述：本程式實現快速傅立葉變換  
** 效能提升：修正了IFFT的bug,變數重新命名,使用巨集定義改變N大小  
** 程式版本：V6.55 
** 程式作者：宋元瑞  
** 最後修改：2011年5月22日  
*******************************************************************************/  
#include "syrFFT_6_55.h"   
  
//產生模擬原始資料輸入 ,在實際應用時替換為AD取樣資料   
void InputData(void)  
{  
    int i;  
    for(i=0; i<N_FFT; i++)//製造輸入序列   
    {  
        data_of_N_FFT[i].real = sin(2*PI*i/N_FFT);  //輸入取樣資料   
        data_of_N_FFT[i].imag = 0;  
    }  
}  
  
//主函式 ，示例如何呼叫FFT運算   
int main(int argc, char *argv[])  
{  
    int i = 0;  
      
    Init_FFT();         //①初始化各項引數，此函式只需執行一次 ; 修改FFT的點數去標頭檔案的巨集定義處修改   
      
    InputData();        //②輸入原始資料 ,此處在實際應用時替換為AD取樣資料   
    FFT();              //③進行 FFT計算   
    //for(i=0; i<N_FFT; i++)//④輸出FFT頻譜結果  sqrt(data_of_N_FFT[i].real*data_of_N_FFT[i].real+data_of_N_FFT[i].imag*data_of_N_FFT[i].imag)  
        //{printf("%f ",FFT_RESULT(i));}  
      
    IFFT();//進行 IFFT計算   
    //for(i=0; i<N_FFT; i++)//(可選步驟)⑤輸出 IFFT結果 ，濾波時會用到；暫時不用   
        //{printf("%f ",IFFT_RESULT(i));}  
      
    Close_FFT();    //結束 FFT運算，此版本此句無用，可不寫   
      
    return 0;  
}  


