; .\output\util.SRC generated from: util.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE util.c OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND CODE PRINT(.\lst\util.lst) SRC(.\output\util.SRC)

$NOMOD51

NAME	UTIL

P0	DATA	080H
P1	DATA	090H
P2	DATA	0A0H
P3	DATA	0B0H
T0	BIT	0B0H.4
AC	BIT	0D0H.6
T1	BIT	0B0H.5
T2	BIT	090H.0
EA	BIT	0A8H.7
IE	DATA	0A8H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
ES	BIT	0A8H.4
IP	DATA	0B8H
RI	BIT	098H.0
INT0	BIT	0B0H.2
CY	BIT	0D0H.7
TI	BIT	098H.1
INT1	BIT	0B0H.3
RCAP2H	DATA	0CBH
PS	BIT	0B8H.4
SP	DATA	081H
T2EX	BIT	090H.1
OV	BIT	0D0H.2
RCAP2L	DATA	0CAH
C_T2	BIT	0C8H.1
WR	BIT	0B0H.6
RCLK	BIT	0C8H.5
TCLK	BIT	0C8H.4
SBUF	DATA	099H
PCON	DATA	087H
SCON	DATA	098H
TMOD	DATA	089H
TCON	DATA	088H
IE0	BIT	088H.1
IE1	BIT	088H.3
B	DATA	0F0H
CP_RL2	BIT	0C8H.0
ACC	DATA	0E0H
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RB8	BIT	098H.2
TH0	DATA	08CH
EX0	BIT	0A8H.0
IT0	BIT	088H.0
TH1	DATA	08DH
TB8	BIT	098H.3
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
SM0	BIT	098H.7
TL0	DATA	08AH
SM1	BIT	098H.6
TL1	DATA	08BH
WDTCON	DATA	0D8H
SM2	BIT	098H.5
TL2	DATA	0CCH
PT0	BIT	0B8H.1
PT1	BIT	0B8H.3
RS0	BIT	0D0H.3
PT2	BIT	0B8H.5
TR0	BIT	088H.4
RS1	BIT	0D0H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DPH	DATA	083H
DPL	DATA	082H
EXEN2	BIT	0C8H.3
REN	BIT	098H.4
T2CON	DATA	0C8H
RXD	BIT	0B0H.0
CKCON	DATA	08EH
TXD	BIT	0B0H.1
F0	BIT	0D0H.5
PSW	DATA	0D0H
?PR?_Hextable?UTIL   SEGMENT CODE 
?PR?_UartByte2HexNoCR?UTIL               SEGMENT CODE 
?DT?UTIL             SEGMENT DATA 
?PR?_UartByte2Hex?UTIL                   SEGMENT CODE 
?PR?_UartWord2Hex?UTIL                   SEGMENT CODE 
?PR?UartCarryReturn?UTIL                 SEGMENT CODE 
?PR?_UartChar?UTIL   SEGMENT CODE 
?PR?_UartString?UTIL SEGMENT CODE 
?PR?_Delay1MS?UTIL   SEGMENT CODE 
?PR?_Delay10US?UTIL  SEGMENT CODE 
?PR?EnableAsyncTimer?UTIL                SEGMENT CODE 
?PR?_SetupAsyncTimer?UTIL                SEGMENT CODE 
?PR?Timer0ISR?UTIL   SEGMENT CODE 
?PR?IsAsyncTimeOut?UTIL                  SEGMENT CODE 
?PR?Timer1ISR?UTIL   SEGMENT CODE 
?PR?_DWORDBig2Little_f?UTIL              SEGMENT CODE 
?DT?_DWORDBig2Little_f?UTIL              SEGMENT DATA OVERLAYABLE 
	EXTRN	DATA (wAsyncCnt)
	EXTRN	XDATA (pfISROfTime1)
	EXTRN	BIT (xAsyncTimeOut)
	EXTRN	CODE (?C?CLDPTR)
	EXTRN	CODE (?C?ICALL)
	EXTRN	CODE (?C?CLDOPTR)
	EXTRN	CODE (?C?CSTPTR)
	EXTRN	CODE (?C?CSTOPTR)
	PUBLIC	?_DWORDBig2Little_f?BYTE
	PUBLIC	_DWORDBig2Little_f
	PUBLIC	Timer1ISR
	PUBLIC	IsAsyncTimeOut
	PUBLIC	Timer0ISR
	PUBLIC	_SetupAsyncTimer
	PUBLIC	EnableAsyncTimer
	PUBLIC	_Delay10US
	PUBLIC	_Delay1MS
	PUBLIC	_UartString
	PUBLIC	_UartChar
	PUBLIC	UartCarryReturn
	PUBLIC	_UartWord2Hex
	PUBLIC	_UartByte2Hex
	PUBLIC	_UartByte2HexNoCR
	PUBLIC	_Hextable

	RSEG  ?DT?UTIL
   bUartTmp?549:   DS   1

	RSEG  ?DT?UTIL
      dByte?550:   DS   1

	RSEG  ?DT?UTIL
       bTmp?142:   DS   1

	RSEG  ?DT?UTIL
      dByte?143:   DS   1

	RSEG  ?DT?_DWORDBig2Little_f?UTIL
?_DWORDBig2Little_f?BYTE:
    dwDest?1456:   DS   3
     dwSrc?1457:   DS   3

	RSEG  ?DT?UTIL
      dWord?346:   DS   2

	RSEG  ?DT?UTIL
       bTmp?347:   DS   1
; /************************************************************************|
; |                  A L C O R   M I C R O,  C O R P.                      |
; |                                                                        |
; |         This source code is classified as confidential and             |
; |         contains trade secrets owned by Alcor Micro, Corp.             |
; |                                                                        |
; |                         (C)Copyright 2008                              |
; |                         Alcor Micro, Corp.                             |
; |                        All rights reserved.                            |
; |************************************************************************/
; 
; #include "globaldef.h"
; #include "regmap.h"
; #include "globalvar.h"
; #include "util.h"
; 
; // Hex code convert to ASCII code
; BYTE Hextable(BYTE index)

	RSEG  ?PR?_Hextable?UTIL
_Hextable:
	USING	0
			; SOURCE LINE # 18
;---- Variable 'index?040' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 19
;     if(index < 10){
			; SOURCE LINE # 20
	MOV  	A,R7
	CLR  	C
	SUBB 	A,#0AH
	MOV  	A,R7
	JNC  	?C0001
;         return (index+0x30);
			; SOURCE LINE # 21
	ADD  	A,#030H
	MOV  	R7,A
	RET  	
;     }else{
			; SOURCE LINE # 22
?C0001:
;         return (index+0x37);
			; SOURCE LINE # 23
	ADD  	A,#037H
	MOV  	R7,A
;     }
			; SOURCE LINE # 24
; }
			; SOURCE LINE # 25
?C0002:
	RET  	
; END OF _Hextable

; // Byte to hex code
; 
; void UartByte2HexNoCR(BYTE idByte)

	RSEG  ?PR?_UartByte2HexNoCR?UTIL
_UartByte2HexNoCR:
	USING	0
			; SOURCE LINE # 28
;---- Variable 'idByte?141' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 29
;    static BYTE  data bTmp;
;    static BYTE data dByte;
;    dByte = idByte;
			; SOURCE LINE # 32
	MOV  	dByte?143,R7
;    bTmp=(dByte>>4);
			; SOURCE LINE # 33
	MOV  	A,dByte?143
	SWAP 	A
	ANL  	A,#0FH
	MOV  	bTmp?142,A
;    bTmp=Hextable(bTmp);  //first high nibble
			; SOURCE LINE # 34
	MOV  	R7,A
	LCALL	_Hextable
	MOV  	bTmp?142,R7
;    UartChar(bTmp);
			; SOURCE LINE # 35
	LCALL	_UartChar
;    bTmp=(dByte&0x0f);
			; SOURCE LINE # 36
	MOV  	A,dByte?143
	ANL  	A,#0FH
	MOV  	bTmp?142,A
;    bTmp=Hextable(bTmp);  //low nibble
			; SOURCE LINE # 37
	MOV  	R7,A
	LCALL	_Hextable
	MOV  	bTmp?142,R7
;    UartChar(bTmp);
			; SOURCE LINE # 38
	LJMP 	_UartChar
; END OF _UartByte2HexNoCR

; 
; }    
; void UartByte2Hex(BYTE dByte)

	RSEG  ?PR?_UartByte2Hex?UTIL
_UartByte2Hex:
	USING	0
			; SOURCE LINE # 41
;---- Variable 'dByte?244' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 42
;    UartByte2HexNoCR(dByte);
			; SOURCE LINE # 43
	LCALL	_UartByte2HexNoCR
;    UartCarryReturn();
			; SOURCE LINE # 44
	LJMP 	UartCarryReturn
; END OF _UartByte2Hex

; }
; // Word to hex code
; void UartWord2Hex(WORD idWord)

	RSEG  ?PR?_UartWord2Hex?UTIL
_UartWord2Hex:
	USING	0
			; SOURCE LINE # 47
;---- Variable 'idWord?345' assigned to Register 'R6/R7' ----
; {
			; SOURCE LINE # 48
;     static WORD data dWord;
;     static BYTE data bTmp;
;     dWord = idWord;
			; SOURCE LINE # 51
	MOV  	dWord?346,R6
	MOV  	dWord?346+01H,R7
;     bTmp=(BYTE)(dWord>>8);
			; SOURCE LINE # 52
	MOV  	A,dWord?346
	MOV  	bTmp?347,A
;     UartByte2HexNoCR(bTmp);      //high byte
			; SOURCE LINE # 53
	MOV  	R7,bTmp?347
	LCALL	_UartByte2HexNoCR
;     bTmp=(BYTE)(dWord&0x00ff);
			; SOURCE LINE # 54
	MOV  	A,dWord?346+01H
	MOV  	bTmp?347,A
;     UartByte2Hex(bTmp);      //low byte
			; SOURCE LINE # 55
	MOV  	R7,bTmp?347
	LJMP 	_UartByte2Hex
; END OF _UartWord2Hex

; }
; // Insert Carry return, New Line feed into UART debug message pool
; void UartCarryReturn(void)

	RSEG  ?PR?UartCarryReturn?UTIL
UartCarryReturn:
	USING	0
			; SOURCE LINE # 58
; {
			; SOURCE LINE # 59
;     UartChar(0xa);
			; SOURCE LINE # 60
	MOV  	R7,#0AH
	LCALL	_UartChar
;     UartChar(0xd);
			; SOURCE LINE # 61
	MOV  	R7,#0DH
	LJMP 	_UartChar
; END OF UartCarryReturn

; }
; // **********************************************************************************
; // Function description:
; // Name:     UartChar
; // Created:  Lear Hsieh 2008,Aug,18
; // Parameter: BYTE data dByte
; // Return:  void
; // Comment: Use timer1 for UART baudrate timing control
; //          Timer1 is internal timer mode: One tick time perious =  1/(master clock) 
; //          Timer1 ISR is not necessary for main loop routine busy waiting
; //          DO NOT modify this function except you have measured UART TX signal and it works 
; //          properly
; //          UART mode, start bit low, 8 bits data, stop bit high, no parity check
; //			2009,03,25
; //			Release Timer1, support baudrate to 115200
; //
; // **********************************************************************************
; 
; void UartChar(BYTE data idByte)

	RSEG  ?PR?_UartChar?UTIL
_UartChar:
			; SOURCE LINE # 80
;---- Variable 'idByte?548' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 81
;   static BYTE data bUartTmp;
;   static BYTE data dByte;
;   bUartTmp = 8;
			; SOURCE LINE # 84
	MOV  	bUartTmp?549,#08H
;   dByte = idByte;
			; SOURCE LINE # 85
	MOV  	dByte?550,R7
;   SetRegBits(REG_GPIO1_DIR, 0x1);
			; SOURCE LINE # 86
	MOV  	DPTR,#022H
	MOVX 	A,@DPTR
	ORL  	A,#01H
	MOVX 	@DPTR,A
;   // SetRegBits(REG_GPIO2_DIR, 0x1);	
; #pragma ASM
; 	; start bit low, 8.6805 us(115200 baudrate)
	  ; start bit low, 8.6805 us(115200 baudrate)
; 	MOV		R7, #05H	
	  MOV		R7, #05H	
;  	MOV     DPTR,#020H	;GPIO0	
	  MOV     DPTR,#020H	;GPIO0	
; 	MOVX    A,@DPTR			
	  MOVX    A,@DPTR			
; 	ANL     A,#0FEH			
	  ANL     A,#0FEH			
; 	MOVX    @DPTR,A			
	  MOVX    @DPTR,A			
; STARTBITLOW:
	  STARTBITLOW:
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop		
	  nop		
; 	DJNZ 	R7, STARTBITLOW	
	  DJNZ 	R7, STARTBITLOW	
; DATABITHIGH:
	  DATABITHIGH:
; 	MOV     A,dByte?550
	  MOV     A,dByte?550
; 	JNB		ACC.0, DATABITLOW
	  JNB		ACC.0, DATABITLOW
; 	; Data Bit High
	  ; Data Bit High
; 	MOV		DPTR, #020H	;GPIO0
	  MOV		DPTR, #020H	;GPIO0
; 	MOVX	A, @DPTR
	  MOVX	A, @DPTR
; 	ORL		A, #01H
	  ORL		A, #01H
; 	MOVX	@DPTR, A
	  MOVX	@DPTR, A
; 	MOV		R7, #04H
	  MOV		R7, #04H
; HIGHLEVEL:
	  HIGHLEVEL:
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop		
	  nop		
; 	DJNZ 	R7, HIGHLEVEL
	  DJNZ 	R7, HIGHLEVEL
; 	JMP		SHIFTDATABIT
	  JMP		SHIFTDATABIT
; DATABITLOW:
	  DATABITLOW:
; 	MOV		DPTR,#020H	;GPIO0
	  MOV		DPTR,#020H	;GPIO0
; 	MOVX	A,@DPTR
	  MOVX	A,@DPTR
; 	ANL		A,#0FEH
	  ANL		A,#0FEH
; 	MOVX	@DPTR, A
	  MOVX	@DPTR, A
; 	MOV		R7, #04H
	  MOV		R7, #04H
; LOWLEVEL:
	  LOWLEVEL:
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop		
	  nop		
; 	DJNZ 	R7, LOWLEVEL
	  DJNZ 	R7, LOWLEVEL
; SHIFTDATABIT:
	  SHIFTDATABIT:
; 	MOV     A,dByte?550
	  MOV     A,dByte?550
; 	CLR     C
	  CLR     C
; 	RRC     A
	  RRC     A
; 	MOV     dByte?550,A
	  MOV     dByte?550,A
; 	DJNZ    bUartTmp?549, DATABITHIGH
	  DJNZ    bUartTmp?549, DATABITHIGH
; 	; StartBit high
	  ; StartBit high
; 	MOV		DPTR,#020H	;GPIO0
	  MOV		DPTR,#020H	;GPIO0
; 	MOVX	A,@DPTR
	  MOVX	A,@DPTR
; 	ORL		A,#01H
	  ORL		A,#01H
; 	MOV		R7, #04H
	  MOV		R7, #04H
; 	MOVX	@DPTR, A
	  MOVX	@DPTR, A
; STOPBITHIGH:	
	  STOPBITHIGH:	
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	DJNZ 	R7, STOPBITHIGH
	  DJNZ 	R7, STOPBITHIGH
; #pragma ENDASM
; }
			; SOURCE LINE # 159
	RET  	
; END OF _UartChar

; 
; #if 0
; void UartChar(BYTE data idByte)
; {
;   static BYTE data bTmp;
;   static BYTE data dByte;
;   dByte = idByte;
;   SetRegBits(REG_GPIO1_DIR, 0x1);
;   // SetRegBits(REG_GPIO2_DIR, 0x1);	
;   TMOD = (TMOD & 0x0F) | 0x10;
;   TCON &= 0x3F;                     // Clear TF1, TR1
;   ClrRegBits(REG_GPIO1_DATA, 0x1);  // Start bit low
;   // ClrRegBits(REG_GPIO2_DATA, 0x1);
;   // UART Delay
;   TH1 = 0xFF;                       /* 26 us for 38400 baudrate*/
;   TL1 = 0xEC;   
;   _nop_();_nop_();
;   TR1 = 1;
;   while(TF1 !=1);
;   TCON &= 0x3F;
;   bTmp = 8;
;   do{
;     if(dByte & 0x01){
;         SetRegBits(REG_GPIO1_DATA, 0x1);
; 		// SetRegBits(REG_GPIO2_DATA, 0x1);
;         TH1 = 0xFF;                 /* 26 us for 38400 baudrate*/
;         TL1 = 0xEB;    
;     }else{
;        	ClrRegBits(REG_GPIO1_DATA, 0x1);
; 		// ClrRegBits(REG_GPIO2_DATA, 0x1);
;         TH1 = 0xFF;                 /* 26 us for 38400 baudrate*/
;         TL1 = 0xEB;    
;     }
;     TR1 = 1;
;     while(TF1 !=1);
;     TCON &= 0x3F;
;     dByte>>=1;
;     bTmp--;
;   }while(bTmp!=0);
;   // Stop bit high
;   SetRegBits(REG_GPIO1_DATA, 0x1);
;   // SetRegBits(REG_GPIO2_DATA, 0x1);
; 
;   TH1 = 0xFF;    /* 26 us for 38400 baudrate*/
;   TL1 = 0xEC;    
;   TR1 = 1;
;   while(TF1 !=1);
;   TCON &= 0x3F;
; }
; #endif
; // UART string function
; void UartString(char *ptr)

	RSEG  ?PR?_UartString?UTIL
_UartString:
	USING	0
			; SOURCE LINE # 211
;---- Variable 'ptr?651' assigned to Register 'R1/R2/R3' ----
; {
			; SOURCE LINE # 212
;      // bTmp assign to R7, do not need to do data overlay correction
;      BYTE data bTmp;
; 
;      bTmp=*ptr;
			; SOURCE LINE # 216
;---- Variable 'bTmp?652' assigned to Register 'R7' ----
	SJMP 	?C0025
?C0009:
;      while(bTmp)     //last char is "0"
			; SOURCE LINE # 217
	MOV  	A,R7
	JZ   	?C0010
;      {
			; SOURCE LINE # 218
;      	UartChar(bTmp);
			; SOURCE LINE # 219
	LCALL	_UartChar
;      	ptr++;
			; SOURCE LINE # 220
	MOV  	A,#01H
	ADD  	A,R1
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
;      	bTmp=*ptr;
			; SOURCE LINE # 221
?C0025:
	LCALL	?C?CLDPTR
	MOV  	R7,A
;      }
			; SOURCE LINE # 222
	SJMP 	?C0009
?C0010:
;      UartCarryReturn();
			; SOURCE LINE # 223
	LJMP 	UartCarryReturn
; END OF _UartString

; }
; // 2009,03,25 Lear modified
; // use nop to delay, release timer 1
; void Delay1MS(BYTE bCnt)

	RSEG  ?PR?_Delay1MS?UTIL
_Delay1MS:
			; SOURCE LINE # 227
;---- Variable 'bCnt?753' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 228
; 	bCnt = bCnt;	// prevent compiler warning
			; SOURCE LINE # 229
; #pragma ASM
; 	;bCnt assign to R7
	  ;bCnt assign to R7
; DELAY1MSCNT:
	  DELAY1MSCNT:
; 	MOV	bUartTmp?549, #03H
	  MOV	bUartTmp?549, #03H
; DEALY1MSINNERLOOP2:	
	  DEALY1MSINNERLOOP2:	
; 	MOV	dByte?550, #0EBH
	  MOV	dByte?550, #0EBH
; DEALY1MSINNERLOOP1:	
	  DEALY1MSINNERLOOP1:	
; 	nop 
	  nop 
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	DJNZ	dByte?550, 	DEALY1MSINNERLOOP1
	  DJNZ	dByte?550, 	DEALY1MSINNERLOOP1
; 	DJNZ	bUartTmp?549,	DEALY1MSINNERLOOP2	
	  DJNZ	bUartTmp?549,	DEALY1MSINNERLOOP2	
; 	DJNZ	R7,	DELAY1MSCNT
	  DJNZ	R7,	DELAY1MSCNT
; #pragma ENDASM
; }
			; SOURCE LINE # 251
	RET  	
; END OF _Delay1MS

; void Delay10US(BYTE bCnt)

	RSEG  ?PR?_Delay10US?UTIL
_Delay10US:
			; SOURCE LINE # 252
;---- Variable 'bCnt?854' assigned to Register 'R7' ----
; {
			; SOURCE LINE # 253
; 	bCnt = bCnt;	// prevent compiler warning
			; SOURCE LINE # 254
; #pragma ASM
; 	;bCnt assign to R7
	  ;bCnt assign to R7
; DELAY10USCNT:	
	  DELAY10USCNT:	
; 	MOV	dByte?550, #05H
	  MOV	dByte?550, #05H
; DEALY10USINNERLOOP1:	
	  DEALY10USINNERLOOP1:	
; 	nop
	  nop
; 	nop 
	  nop 
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	nop
	  nop
; 	DJNZ	dByte?550, 	DEALY10USINNERLOOP1
	  DJNZ	dByte?550, 	DEALY10USINNERLOOP1
; 	DJNZ	R7,	DELAY10USCNT
	  DJNZ	R7,	DELAY10USCNT
; #pragma ENDASM
; 
; }
			; SOURCE LINE # 280
	RET  	
; END OF _Delay10US

; /*
; void Delay1MS(BYTE bCnt)
; {
;     TMOD = (TMOD & 0x0F) | 0x10;; // internal counter
;     TCON &= 0x3F;
;     _nop_();
;     do{
;         if((Reg[REG_MCU_CLK] & 0x3) == OSC_FREQ_12M){
; 	        // MCU master clock is 12MHz
; 	        TH1 = 0xFC;    
;             TL1 = 0x20;   
;         }else if((Reg[REG_MCU_CLK] & 0x3) == OSC_FREQ_6M){
;             // MCU master clock is 6MHz
;             TH1 = 0xFE;    
;             TL1 = 0x10;
;         }
;         TR1 = 1;
;         while(TF1 !=1);
;         TCON &= 0x3F;
;         bCnt--;
;     }while(bCnt != 0);
; 
; } 
; */
; 
; /*
; void Delay10US(BYTE bCnt)
; {
;     TMOD = (TMOD & 0x0F) | 0x10;; // internal counter
;     TCON &= 0x3F;
;     _nop_();
;     do{
;         if((Reg[REG_MCU_CLK] & 0x3) == OSC_FREQ_12M){
; 	        // MCU master clock is 12MHz
; 	        TH1 = 0xFF;    
;             TL1 = 0xF6;   
;         }else if((Reg[REG_MCU_CLK] & 0x3) == OSC_FREQ_6M){
;             // MCU master clock is 6MHz
;             TH1 = 0xFF;    
;             TL1 = 0xFB;
;         }
;         TR1 = 1;
;         while(TF1 !=1);
;         TCON &= 0x3F;
;         bCnt--;
;     }while(bCnt != 0);
; }
; */
; // Asynchronous timer function
; // Setup Timer 0 for asynchronous delay waiting
; // 16 bits reload and counting mode
; // external source clock is always 5ms
; 
; void EnableAsyncTimer()

	RSEG  ?PR?EnableAsyncTimer?UTIL
EnableAsyncTimer:
			; SOURCE LINE # 334
; {
			; SOURCE LINE # 335
;     // TR2 = 0;        // Stop timer0
;     // T2CON = 0x2;    // event counting mode, 16 bits auto-reload mode
;     TMOD = (TMOD & 0xF0) | 0x05;  /* Set T/C0 Mode 16 bits timer0, external Clock */
			; SOURCE LINE # 338
	MOV  	A,TMOD
	ANL  	A,#0F0H
	ORL  	A,#05H
	MOV  	TMOD,A
;     IE |= 0x82; /*EA = 1, ET0 = 1*/
			; SOURCE LINE # 339
	ORL  	IE,#082H
; } 
			; SOURCE LINE # 340
	RET  	
; END OF EnableAsyncTimer

;  
; void SetupAsyncTimer(WORD wCnt)

	RSEG  ?PR?_SetupAsyncTimer?UTIL
_SetupAsyncTimer:
			; SOURCE LINE # 342
;---- Variable 'wCnt?1055' assigned to Register 'R6/R7' ----
; {
			; SOURCE LINE # 343
;     TR0 = 0;
			; SOURCE LINE # 344
	CLR  	TR0
;     xAsyncTimeOut = FALSE;
			; SOURCE LINE # 345
	CLR  	xAsyncTimeOut
;     wAsyncCnt = wCnt;
			; SOURCE LINE # 346
	MOV  	wAsyncCnt,R6
	MOV  	wAsyncCnt+01H,R7
;     TH0 = 0xFE;
			; SOURCE LINE # 347
	MOV  	TH0,#0FEH
;     TL0 = 0x0C;
			; SOURCE LINE # 348
	MOV  	TL0,#0CH
;     TR0 = 1;
			; SOURCE LINE # 349
	SETB 	TR0
; } 
			; SOURCE LINE # 350
	RET  	
; END OF _SetupAsyncTimer

CSEG	AT	0000BH
	LJMP	Timer0ISR

; 
; void Timer0ISR(void) interrupt 1 using 1

	RSEG  ?PR?Timer0ISR?UTIL
	USING	1
Timer0ISR:
	PUSH 	ACC
			; SOURCE LINE # 352
; {
;     if(wAsyncCnt == 0){
			; SOURCE LINE # 354
	MOV  	A,wAsyncCnt+01H
	ORL  	A,wAsyncCnt
	JNZ  	?C0016
;         xAsyncTimeOut = TRUE;
			; SOURCE LINE # 355
	SETB 	xAsyncTimeOut
;         TR0 = 0;  
			; SOURCE LINE # 356
	CLR  	TR0
;     }else{
			; SOURCE LINE # 357
	SJMP 	?C0018
?C0016:
;         wAsyncCnt--;
			; SOURCE LINE # 358
	MOV  	A,wAsyncCnt+01H
	DEC  	wAsyncCnt+01H
	JNZ  	?C0024
	DEC  	wAsyncCnt
?C0024:
;         TH0 = 0xFE;
			; SOURCE LINE # 359
	MOV  	TH0,#0FEH
;         TL0 = 0x0C;
			; SOURCE LINE # 360
	MOV  	TL0,#0CH
;         TR0 = 1;  
			; SOURCE LINE # 361
	SETB 	TR0
;     }          
			; SOURCE LINE # 362
; }
			; SOURCE LINE # 363
?C0018:
	POP  	ACC
	RETI 	
; END OF Timer0ISR

; 
; BOOLEAN IsAsyncTimeOut(void)

	RSEG  ?PR?IsAsyncTimeOut?UTIL
IsAsyncTimeOut:
	USING	0
			; SOURCE LINE # 365
; {
			; SOURCE LINE # 366
;     if(xAsyncTimeOut == TRUE){
			; SOURCE LINE # 367
	JNB  	xAsyncTimeOut,?C0019
;         xAsyncTimeOut = FALSE;
			; SOURCE LINE # 368
	CLR  	xAsyncTimeOut
;         return TRUE;
			; SOURCE LINE # 369
	MOV  	R7,#01H
	RET  	
;     }else{
			; SOURCE LINE # 370
?C0019:
;         return FALSE;
			; SOURCE LINE # 371
	MOV  	R7,#00H
;     }           
			; SOURCE LINE # 372
; }    
			; SOURCE LINE # 373
?C0020:
	RET  	
; END OF IsAsyncTimeOut

CSEG	AT	0001BH
	LJMP	Timer1ISR

; 
; //Interrupt Number=(interrupt_address - 3) / 8
; 
; void Timer1ISR(void) interrupt 3 using 1

	RSEG  ?PR?Timer1ISR?UTIL
	USING	1
Timer1ISR:
	PUSH 	ACC
	PUSH 	B
	PUSH 	DPH
	PUSH 	DPL
	PUSH 	PSW
	USING	1
	MOV  	PSW,#08H
			; SOURCE LINE # 377
; {
; 	pfISROfTime1();
			; SOURCE LINE # 379
	MOV  	DPTR,#pfISROfTime1
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,AR6
	MOV  	R1,A
	LCALL	?C?ICALL
; }
			; SOURCE LINE # 380
	POP  	PSW
	POP  	DPL
	POP  	DPH
	POP  	B
	POP  	ACC
	RETI 	
; END OF Timer1ISR

; 
; void DWORDBig2Little_f(DWORD *dwDest, DWORD *dwSrc) 

	RSEG  ?PR?_DWORDBig2Little_f?UTIL
_DWORDBig2Little_f:
	USING	0
			; SOURCE LINE # 382
	MOV  	dwDest?1456,R3
	MOV  	dwDest?1456+01H,R2
	MOV  	dwDest?1456+02H,R1
; {
			; SOURCE LINE # 383
;     *((BYTE *)&(*dwDest)) = *((BYTE *)&(*dwSrc)+3);
			; SOURCE LINE # 384
	MOV  	R3,dwSrc?1457
	MOV  	R2,dwSrc?1457+01H
	MOV  	R1,dwSrc?1457+02H
	MOV  	DPTR,#03H
	LCALL	?C?CLDOPTR
	MOV  	R3,dwDest?1456
	MOV  	R2,dwDest?1456+01H
	MOV  	R1,dwDest?1456+02H
	LCALL	?C?CSTPTR
;     *((BYTE *)&(*dwDest)+1) = *((BYTE *)&(*dwSrc)+2);
			; SOURCE LINE # 385
	MOV  	R3,dwSrc?1457
	MOV  	R2,dwSrc?1457+01H
	MOV  	R1,dwSrc?1457+02H
	MOV  	DPTR,#02H
	LCALL	?C?CLDOPTR
	MOV  	R3,dwDest?1456
	MOV  	R2,dwDest?1456+01H
	MOV  	R1,dwDest?1456+02H
	MOV  	DPTR,#01H
	LCALL	?C?CSTOPTR
;     *((BYTE *)&(*dwDest)+2) = *((BYTE *)&(*dwSrc)+1);
			; SOURCE LINE # 386
	MOV  	R3,dwSrc?1457
	MOV  	R2,dwSrc?1457+01H
	MOV  	R1,dwSrc?1457+02H
	MOV  	DPTR,#01H
	LCALL	?C?CLDOPTR
	MOV  	R3,dwDest?1456
	MOV  	R2,dwDest?1456+01H
	MOV  	R1,dwDest?1456+02H
	MOV  	DPTR,#02H
	LCALL	?C?CSTOPTR
;     *((BYTE *)&(*dwDest)+3) = *((BYTE *)&(*dwSrc));
			; SOURCE LINE # 387
	MOV  	R3,dwSrc?1457
	MOV  	R2,dwSrc?1457+01H
	MOV  	R1,dwSrc?1457+02H
	LCALL	?C?CLDPTR
	MOV  	R3,dwDest?1456
	MOV  	R2,dwDest?1456+01H
	MOV  	R1,dwDest?1456+02H
	MOV  	DPTR,#03H
	LJMP 	?C?CSTOPTR
; END OF _DWORDBig2Little_f

	END
